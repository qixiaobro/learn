### 数值的扩展

1. 二进制和八进制表示法  
二进制：`0b`或`0B`  
八进制：`0o`或`0O`  

2. `Number.isFinite()`、`Number.isNaN()`
`Number.isFinite()`用来检查一个数值是否为有限的（finite），即不是Infinity。  
`Number.isNaN()`用来检查一个值是否为NaN。  

它们与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，`Number.isFinite()`对于非数值一律返回false, `Number.isNaN()`只有对于NaN才返回true，非NaN一律返回false。  

3. `Number.parseInt()`、`Number.parseFloat()`  
ES6将全局的`parseInt()`、`parseFloat()`移植到`Number`对象上，行为完全不变，为了减少全局性方法，使得语言逐步模块化。

4. `Number.isInteger()`  
`Number.isInteger()`用来判断一个数值是否为整数。  
**注意**
JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 
 
```
Number.isInteger(25) // true
Number.isInteger(25.0) // true
```
如果参数不是数值，Number.isInteger返回false。
```
Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
```
注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，```Number.isInteger```可能会误判。
```
Number.isInteger(3.0000000000000002) // true
```
上面代码中，```Number.isInteger```的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。

类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，```Number.isInteger```也会误判。
```
Number.isInteger(5E-324) // false
Number.isInteger(5E-325) // true
```
上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。

总之，如果对数据精度的要求较高，不建议使用```Number.isInteger()```判断一个数值是否为整数。

5. ```Number.EPSLION```  
表示1与大于1的最小浮点数之间的差，即2的-52次方。
```Number.EPSILON```实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。
```
//误差检测函数
function withinErrorMargin (left, right) {
  return Math.abs(left - right) < Number.EPSILON * Math.pow(2, 2);
}

0.1 + 0.2 === 0.3 // false
withinErrorMargin(0.1 + 0.2, 0.3) // true

1.1 + 1.3 === 2.4 // false
withinErrorMargin(1.1 + 1.3, 2.4) // true
```

6. 安全整数和```Number.isSafeInteger()```  
JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。
```Number.MAX_SAFE_INTEGER、Number.MIN_SAFE_INTEGER()```
表示整数的上下限  
```Number.isSageInteger()```判断一个数是否在安全范围内。  
函数实现方式：
```
Number.isSafeInteger = function (n) {
  return (typeof n === 'number' &&
    Math.round(n) === n &&
    Number.MIN_SAFE_INTEGER <= n &&
    n <= Number.MAX_SAFE_INTEGER);
}
```
**注意**  
使用这个方法要同时验证参与计算的每个数值。
```
function trusty (left, right, result) {
  if (
    Number.isSafeInteger(left) &&
    Number.isSafeInteger(right) &&
    Number.isSafeInteger(result)
  ) {
    return result;
  }
  throw new RangeError('Operation cannot be trusted!');
}

trusty(9007199254740993, 990, 9007199254740993 - 990)
// RangeError: Operation cannot be trusted!

trusty(1, 2, 3)
// 3
```