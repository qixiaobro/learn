### 数值的扩展

1. 二进制和八进制表示法  
>>>二进制：`0b`或`0B`  
>>>八进制：`0o`或`0O`  

2. `Number.isFinite()`、`Number.isNaN()`
>>>`Number.isFinite()`用来检查一个数值是否为有限的（finite），即不是Infinity。  
`Number.isNaN()`用来检查一个值是否为NaN。  

>>>它们与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，`Number.isFinite()`对于非数值一律返回false, `Number.isNaN()`只有对于NaN才返回true，非NaN一律返回false。  

3. `Number.parseInt()`、`Number.parseFloat()`  
>>>ES6将全局的`parseInt()`、`parseFloat()`移植到`Number`对象上，行为完全不变，为了减少全局性方法，使得语言逐步模块化。

4. `Number.isInteger()`  
>>>`Number.isInteger()`用来判断一个数值是否为整数。  
>>>**注意**
>>>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 
 
```
Number.isInteger(25) // true
Number.isInteger(25.0) // true
```
>>>如果参数不是数值，Number.isInteger返回false。
```
Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
```
>>>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，```Number.isInteger```可能会误判。
```
Number.isInteger(3.0000000000000002) // true
```
>>>上面代码中，```Number.isInteger```的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。

>>>类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，```Number.isInteger```也会误判。
```
Number.isInteger(5E-324) // false
Number.isInteger(5E-325) // true
```
>>>上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。

>>>总之，如果对数据精度的要求较高，不建议使用```Number.isInteger()```判断一个数值是否为整数。