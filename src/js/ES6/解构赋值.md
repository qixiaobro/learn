### 解构赋值

#### 1. 基础用法

>一种情况属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。
```
let [a, b, c] = [1, 2, 3];
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined /*解构不成功， 变量的值就会变成undefined*/
z // []
```
另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
```
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```
事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

>**默认值**  
```
let [foo = true] = [];
```
只有右边的值严格等于undefined,默认值才会生效
```
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
```
默认值可以等于解构赋值的其它变量，但是这个变量要先声明。
- - -
#### 2. 对象的解构赋值
```
let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: 'aaa', bar: 'bbb' };
baz // undefined
```
对象的解构赋值，顺序不要求，要求属性名必须一致。